diff --git a/external/OpenMesh/Core/IO/reader/BaseReader.hh b/external/OpenMesh/Core/IO/reader/BaseReader.hh
index d1eddfc..b5f1e73 100644
--- a/src/dependencies/MeshSDFilter/external/OpenMesh/Core/IO/reader/BaseReader.hh
+++ b/src/dependencies/MeshSDFilter/external/OpenMesh/Core/IO/reader/BaseReader.hh
@@ -147,6 +147,7 @@ protected:
 		       const std::string& _ext) const;
 };
 
+//SLE https://stackoverflow.com/questions/44973435/stdptr-fun-replacement-for-c17
 
 /** \brief Trim left whitespace
  *
@@ -156,7 +157,7 @@ protected:
  * @return trimmed string
  */
 static inline std::string &left_trim(std::string &_string) {
-  _string.erase(_string.begin(), std::find_if(_string.begin(), _string.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
+    _string.erase(_string.begin(),std::find_if(_string.begin(), _string.end(), [](int c) { return !std::isspace(c); }));
   return _string;
 }
 
@@ -168,7 +169,7 @@ static inline std::string &left_trim(std::string &_string) {
  * @return trimmed string
  */
 static inline std::string &right_trim(std::string &_string) {
-  _string.erase(std::find_if(_string.rbegin(), _string.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), _string.end());
+    _string.erase(std::find_if(_string.rbegin(), _string.rend(), [](int c) { return !std::isspace(c); }).base(),_string.end());
   return _string;
 }
 
diff --git a/external/OpenMesh/Core/Mesh/Handles.hh b/external/OpenMesh/Core/Mesh/Handles.hh
index 6cbb8ac..361c504 100644
--- a/src/dependencies/MeshSDFilter/external/OpenMesh/Core/Mesh/Handles.hh
+++ b/src/dependencies/MeshSDFilter/external/OpenMesh/Core/Mesh/Handles.hh
@@ -40,7 +40,7 @@
  * ========================================================================= */
 
 /*===========================================================================*\
- *                                                                           *             
+ *                                                                           *
  *   $Revision$                                                         *
  *   $Date$                   *
  *                                                                           *
@@ -49,182 +49,177 @@
 #ifndef OPENMESH_HANDLES_HH
 #define OPENMESH_HANDLES_HH
 
-
 //== INCLUDES =================================================================
 
 #include <OpenMesh/Core/System/config.h>
 #include <ostream>
 
-
 //== NAMESPACES ===============================================================
 
-namespace OpenMesh {
+namespace OpenMesh
+{
 
 //== CLASS DEFINITION =========================================================
 
-
 /// Base class for all handle types
 class BaseHandle
-{ 
+{
 public:
-  
-  explicit BaseHandle(int _idx=-1) : idx_(_idx) {}
+    explicit BaseHandle(int _idx = -1)
+        : idx_(_idx)
+    {
+    }
 
-  /// Get the underlying index of this handle
-  int idx() const { return idx_; }
+    /// Get the underlying index of this handle
+    int idx() const { return idx_; }
 
-  /// The handle is valid iff the index is not negative.
-  bool is_valid() const { return idx_ >= 0; }
+    /// The handle is valid iff the index is not negative.
+    bool is_valid() const { return idx_ >= 0; }
 
-  /// reset handle to be invalid
-  void reset() { idx_=-1; }
-  /// reset handle to be invalid
-  void invalidate() { idx_ = -1; }
+    /// reset handle to be invalid
+    void reset() { idx_ = -1; }
+    /// reset handle to be invalid
+    void invalidate() { idx_ = -1; }
 
-  bool operator==(const BaseHandle& _rhs) const { 
-    return (this->idx_ == _rhs.idx_); 
-  }
+    bool operator==(const BaseHandle& _rhs) const { return (this->idx_ == _rhs.idx_); }
 
-  bool operator!=(const BaseHandle& _rhs) const { 
-    return (this->idx_ != _rhs.idx_); 
-  }
+    bool operator!=(const BaseHandle& _rhs) const { return (this->idx_ != _rhs.idx_); }
 
-  bool operator<(const BaseHandle& _rhs) const { 
-    return (this->idx_ < _rhs.idx_); 
-  }
+    bool operator<(const BaseHandle& _rhs) const { return (this->idx_ < _rhs.idx_); }
 
+    // this is to be used only by the iterators
+    void __increment() { ++idx_; }
+    void __decrement() { --idx_; }
 
-  // this is to be used only by the iterators
-  void __increment() { ++idx_; }
-  void __decrement() { --idx_; }
-
-  void __increment(int amount) { idx_ += amount; }
-  void __decrement(int amount) { idx_ -= amount; }
+    void __increment(int amount) { idx_ += amount; }
+    void __decrement(int amount) { idx_ -= amount; }
 
 private:
-
-  int idx_; 
+    int idx_;
 };
 
 // this is used by boost::unordered_set/map
-inline size_t hash_value(const BaseHandle&  h)   { return h.idx(); }
+inline size_t hash_value(const BaseHandle& h)
+{
+    return h.idx();
+}
 
 //-----------------------------------------------------------------------------
 
 /// Write handle \c _hnd to stream \c _os
-inline std::ostream& operator<<(std::ostream& _os, const BaseHandle& _hnd) 
+inline std::ostream& operator<<(std::ostream& _os, const BaseHandle& _hnd)
 {
-  return (_os << _hnd.idx());
+    return (_os << _hnd.idx());
 }
 
-
 //-----------------------------------------------------------------------------
 
-
 /// Handle for a vertex entity
 struct VertexHandle : public BaseHandle
 {
-  explicit VertexHandle(int _idx=-1) : BaseHandle(_idx) {}
+    explicit VertexHandle(int _idx = -1)
+        : BaseHandle(_idx)
+    {
+    }
 };
 
-
 /// Handle for a halfedge entity
 struct HalfedgeHandle : public BaseHandle
 {
-  explicit HalfedgeHandle(int _idx=-1) : BaseHandle(_idx) {}
+    explicit HalfedgeHandle(int _idx = -1)
+        : BaseHandle(_idx)
+    {
+    }
 };
 
-
 /// Handle for a edge entity
 struct EdgeHandle : public BaseHandle
 {
-  explicit EdgeHandle(int _idx=-1) : BaseHandle(_idx) {}
+    explicit EdgeHandle(int _idx = -1)
+        : BaseHandle(_idx)
+    {
+    }
 };
 
-
 /// Handle for a face entity
 struct FaceHandle : public BaseHandle
 {
-  explicit FaceHandle(int _idx=-1) : BaseHandle(_idx) {}
+    explicit FaceHandle(int _idx = -1)
+        : BaseHandle(_idx)
+    {
+    }
 };
 
-
 //=============================================================================
 } // namespace OpenMesh
 //=============================================================================
 
+// SLE update from https://github.com/Lawrencemm/openmesh/blob/master/src/OpenMesh/Core/Mesh/Handles.hh
+
 #ifdef OM_HAS_HASH
 #include <functional>
-namespace std {
+namespace std
+{
 
 #if defined(_MSVC_VER)
-#  pragma warning(push)
-#  pragma warning(disable:4099) // For VC++ it is class hash
+#pragma warning(push)
+#pragma warning(disable : 4099) // For VC++ it is class hash
 #endif
 
-
 template <>
-struct hash<OpenMesh::BaseHandle >
-  : public std::unary_function<OpenMesh::BaseHandle, std::size_t>
+struct hash<OpenMesh::BaseHandle>
 {
+    typedef OpenMesh::BaseHandle argument_type;
+    typedef std::size_t result_type;
 
-  std::size_t operator()(const OpenMesh::BaseHandle& h) const
-  {
-    return h.idx();
-  }
+    std::size_t operator()(const OpenMesh::BaseHandle& h) const { return h.idx(); }
 };
 
 template <>
-struct hash<OpenMesh::VertexHandle >
-  : public std::unary_function<OpenMesh::VertexHandle, std::size_t>
+struct hash<OpenMesh::VertexHandle>
 {
+    typedef OpenMesh::VertexHandle argument_type;
+    typedef std::size_t result_type;
 
-  std::size_t operator()(const OpenMesh::VertexHandle& h) const
-  {
-    return h.idx();
-  }
+    std::size_t operator()(const OpenMesh::VertexHandle& h) const { return h.idx(); }
 };
 
 template <>
-struct hash<OpenMesh::HalfedgeHandle >
-  : public std::unary_function<OpenMesh::HalfedgeHandle, std::size_t>
+struct hash<OpenMesh::HalfedgeHandle>
 {
 
-  std::size_t operator()(const OpenMesh::HalfedgeHandle& h) const
-  {
-    return h.idx();
-  }
+    typedef OpenMesh::HalfedgeHandle argument_type;
+    typedef std::size_t result_type;
+
+    std::size_t operator()(const OpenMesh::HalfedgeHandle& h) const { return h.idx(); }
 };
 
 template <>
-struct hash<OpenMesh::EdgeHandle >
-  : public std::unary_function<OpenMesh::EdgeHandle, std::size_t>
+struct hash<OpenMesh::EdgeHandle>
 {
 
-  std::size_t operator()(const OpenMesh::EdgeHandle& h) const
-  {
-    return h.idx();
-  }
+    typedef OpenMesh::EdgeHandle argument_type;
+    typedef std::size_t result_type;
+
+    std::size_t operator()(const OpenMesh::EdgeHandle& h) const { return h.idx(); }
 };
 
 template <>
-struct hash<OpenMesh::FaceHandle >
-  : public std::unary_function<OpenMesh::FaceHandle, std::size_t>
+struct hash<OpenMesh::FaceHandle>
 {
 
-  std::size_t operator()(const OpenMesh::FaceHandle& h) const
-  {
-    return h.idx();
-  }
+    typedef OpenMesh::FaceHandle argument_type;
+    typedef std::size_t result_type;
+
+    std::size_t operator()(const OpenMesh::FaceHandle& h) const { return h.idx(); }
 };
 
 #if defined(_MSVC_VER)
-#  pragma warning(pop)
+#pragma warning(pop)
 #endif
 
-}
-#endif  // OM_HAS_HASH
-
+} // namespace std
+#endif // OM_HAS_HASH
 
 #endif // OPENMESH_HANDLES_HH
 //=============================================================================
